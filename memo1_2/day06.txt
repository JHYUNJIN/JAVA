컬렉션 프레임워크 (Collection Framework) : 자료 구조
	데이터를 효율적을 처리할 수 있도록 지원하며 이미 구현된 클래스들의 집합이다.

인터페이스, 제네릭, 알고리즘, 동기화
	인터페이스를 통해 제네릭을 사용할 수 있고 알고리즘

1. List 인터페이스 (추상메소드로 되어있어 받을 클래스에서 구현을 해줘야한다.)
	데이터의 순서를 보장한다.
	중복 된 값을 허용한다.
- List 구현 클래스
	Vector : 예전에 사용하던 클래스로 지금은 사용하지 않는다.(자바 기준)
	LinkedList : 추가, 삭제는 빠르지만 탐색이 상대적으로 느리다.
	ArrayList : 배열과 동일하게 인덱스로 데이터를 관리한다.
		컬렉션 클래스 중 실무에서 가장 많이 사용되는 클래스
		추가, 삭제는 상대적으로 느리지만 탐색이 빠르다.
2. Set 인터페이스
set : 집합
	데이터의 순서를 보장하지 않는다.
	데이터의 중복을 허용하지 않는다.

구현 클래스
	HashSet
	Set인터페이스를 구현한 가장 대표적인 클래스
	중복되는 값을 저장하면 무시한다.
	인덱스가 존재하지 않아 순서를 보장하지 않는다.
	ArrayList나 배열처럼 값을 가져오는게 불가능하다.
	hashCode()가 반환하는 해시코드를 이용하여 데이터를 처리하며 속도가 상태적으로 빠르다.
	값의 존재여부를 파악할 때 사용하기 좋다.

Iterator
	컬렉션에 저장된 데이터들을 컬레션의 종류와 상관없이 동일한 방식으로 가져오기 위한 인터페이스이다.
	어떤 자료구조든 Iterator로 변환하면 Iterator만의 방식으로 순서를 만들고 값을 가져올수있다.
	값의 유무를 검사하거나 값을 가져올떄는 커서를 이용한다. hasnext(), next() 

Iterator()
	ArrayList, Hashset 등의 컬렉션 객체를 Iterator 타입으로 변환할 때 사용하는 메소드

hasNext()
	다음 값의 유무를 검사하여 boolean타입으로 반환한다.
next()
	다음 값을 가져온다. 아무 값도 없다면 예외가 발생한다.



향상된 for 문
for(int data; list)
for(int i=0;i<list.sizeof();i++)
hashset은 인덱스 번호가 없기때문에 for문을 사용할 수 없다.


3. Map 인터페이스



배열과 리스트의 차이점
크기 , 타입, 삭제, 포함여부 검사, 수정