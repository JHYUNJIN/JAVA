다형성
	하나의 것이 여러가지 형태를 가질수 있는 성질
	1.오버로딩
	2.오버라이딩
	3.참조변수의 다형성(매개변수의 다형성)
		조상클래스 타입의 참조변수로 자식클래스 객체를 가리키는 것을 허용한다.

객체 간 타입비교
instanceof
	a instanceof A : 조건식 --> 참 또는 거짓 중 하나가 나오는 식

	a가 A타입이면 true
	아니면 	    false


추상 메소드
	메소드를 선언만 하고 구현을 하지 않은 것을 추상메소드라고 한다.(미완성된 메소드)
	ex) abstract void 메소드명(매개변수);
	1. abstract 키워드를 사용한다.
	2. 마지막에 세미콜론을 써야한다.

추상 클래스
	abstract키워드가 붙은 클래스는 추상 클래스이며 추상 메소드가 한개 이상 있는
	클래스는 반드시 추상클래스로 선언해야한다.
	ex) abstract class 클래스명{
		abstract void 메소드명(매개변수);
		*일반 메소드도 선언가능
	}
	1. abstract 키워드를 사용한다.
	2. 객체화  시킬 수 없다.

	** 미완성된 메소드(추상메소드)는 상속받은 자식클래스에서
	반드시 재정의하여 구현을 해야만 해당 클래스를 객체화 할 수 있다.
	그러므로 "강제성"을 부여하기 위해서 추상메소드로 선언한다.

추상클래스를 사용하는 이유
	공통되는 속성과 행위를 추상화하여 부모클래스를 만드는데 반드시 모든
	자식 클래스에서 구현해야하는 메소드가 있다면 추상 메소드로 선언하는게 좋다.
	추상클래스를 상속받는 자식클래스는 추상메소드를 오버라이딩하지 않으면 오류가 발생하므로 "강제성"이 생기게 된다.
	만약 부모클래스에서 메소드를 구현 한다면 강제성이 없으므로 자식클래스를 만드는 개발자가 재정의하지 않고 그냥 넘어갈 수 있다.


인터페이스(interface)
	일종의 추상클래스이지만 클래스라고 부르지 않으며 추상화의 정도가 높다.
	멤버로는 상수와 추상메소드만 가질 수 있다.
	인터페이스는 객체화 할 수 없다.
	인터페이스는 다른 클래스에서 구현(implements)해서 사용한다.
	(상속과 비슷하다.)
	구현할 때는 implements 키워드를 사용한다.

인터페이스의 선언
	interface 인터페이스명{
		멤버선언;
	}

인터페이스의 멤버
	모든 필드(변수)가 public static final이다. (생략해도 자동으로 붙는다.)
	모든 메소드는 public abstract이다. (생략해도 자동으로 붙는다.)

클래스의 상속과 인터페이스의 구현
	클래스는 단일 상속만 가능하다.
	인터페이스는 다중 구현이 가능하다.
	상속과 구현은 별개이다. 즉 하나의 클래스에 상속과 구현을 동시에 할 수 있다.
	인터페이스는 인터페이스를 상속할 수 있다.

인터페이스를 사용하는 이유
	1. 여러 클래스에서 선언할 멤버들을 일관되게 하기 위해 사용한다. (표준화)
	2. 관계없는 클래스들을 그룹화 시킬 수 있다. (마커 인터페이스)
	3. java의 다중상속이 되지않는 문제점을 해결하기 위해 
	     인터페이스를 사용하여 다중구현을 통해 다중상속을 이용한다.

인터페이스의 문제점
	인터페이스는 강제성이 강하기 때문에 구현하는 클래스에서 일부만 재정의하여 사용하는게 불가능하다. 이를 해결하기 위해 adapter라는 추상클래스를 활용한다.

어댑터클래스(추상클래스)와 인터페이스
	인터페이스의 강제성을 완화하기 위해서 어댑터클래스를 사용한다.
	어댑터 클래스는 추상클래스로 만들기 때문에 미구현된 메소드와 구현된 메소드가 동시에 존재할 수 있다.
	그러므로 어댑터 클래스에서 인터페이스를 구현받아 강제성을 없애고 메소드만 재정의해준다. 이 후 어댑터클래스를 상속받는 자식클래스는 내가 원하는 메소드만 재정의 할 수 있게 된다. 이 때 어댑터 클래스 이름 뒤에 Adapter를 붙여주어 목적을 알려주는게 좋다.

다중 상속
	여러 부모클래스를 상속하는것을 다중상속이라고 한다.
	java는 모호성 때문에 다중상속을 지원하지 않는다.

	하지만 jdk8버전 이후부터 인터페이스에 default 메소드 등을 만드는 것을 허용한다.(특정 메소드의 구현을 허용한다.)
	여러개를 구현(상속)할 수 있는 인터페이스의 특징때문에 다중상속을 지원하는 것이나 다름없다.

모호성
	하나의 자식이 여러 부모를 상속받을 때 서로 다른 부모클래스에 동일한 이름의 멤버가 있다면, 어떤 부모의 멤버인지 알 수 없다.

인터페이스의 추가된 기능(jdk8부터 추가됨)
	1. default 메소드를 선언할 수 있다.
		[public] default 리턴타입 메소드명(매개변수){
			실행할 코드;
		]

	2. static 메소드를 선언 할 수 있다.
		[public] default 리턴타입 메소드명(매개변수){
			실행할 코드;
		]
	
	3. private 메소드를 선언할 수 있다.(jdk 9버전부터 사용가능)

모호성 해결방법 예시
	1. 두 개의 인터페이스에 같은 메소드가(이름,매개변수,리턴타입이 같은) 선언되어 있는 경우 자식클래스에서 재정의하여 사용한다.

	2. 부모클래스의 메소드와 인터페이스의 디폴트메소드의 이름과 매개변수가 같은 경우 부모클래스의 메소드가 사용된다.

** 인터페이스도 타입이다.
	인터페이스는 부모이고 구현한 클래스가 자식이다.

마커 인터페이스(Marker Interface)
	클래스들을 그룹화하기 위한 목적으로 사용한다.
	서로 다른 클래스에게 공통된 타입을 갖도록 하는것이 유일한 목적이기 때문에 마커 인터페이스는 어떠한 멤버도 선언하지 않는다.

초식동물		육식동물		잡식동물
얼룩말		  상어		비둘기
사슴		  늑대		개
토끼		  독수리		고양이
기린		 호랑이		원숭이
소		  사자		돼지

Object Class
-java.lang.Object
-모든 클래스의 최상위 클래스
-모든 클래스는 Object 클래스의 메소드를 사용 할 수 있고, 일부 메소드를 오버라이딩하여 사용한다.
- Object클래스가 들어있는 java.lang 패키지는 컴파일러에 의해 자동으로 import된다.

	toString()
	- 객체의 해시코드(주소) 출력
	- 패키지명.클래스명@해시코드
	-getClass().getName(): 패키지명+클래스명
	-Integer.toHexString(hashCode()) : 해시코드

	equals()
	-객체의 값이 같은지 연산 (주소값을 비교하는 것)

	clone()
	-객체의 복사본을 만듬
	-clone()은 객체를 복제할 때 private 필드도 복제하기 때문에 객체지향 프로그래밍의 은닉화에 위배된다.


상수란 public static final INT NUM = 5
public static final 생략가능